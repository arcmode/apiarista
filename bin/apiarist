#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander'),
    async = require('async'),
    wrench = require('wrench'),
    path = require('path'),
    os = require('os'),
    fs = require('fs'),
    child_process = require('child_process'),
    util = require('util');

program
  .version(require('../package').version)
  .option('-r, resource [ResourceName]', 'generate resource')
  .option('-f, --force', 'force on existing files')
  .option('-X, --FLUSH', 'deletes the api')
  .parse(process.argv);

// end-of-line code

var eol = 'win32' == os.platform() ? '\r\n' : '\n';

// utility to propercase the resource name

String.prototype.toProperCase = function () {
    return this.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
};

if (program.resource) {

  if ('string' === typeof program.resource) {

    var sourceDirs = [
      '/api',
      '/data'
    ];

    var templateDir = path.join(__dirname,
                        '../node_modules/api-template'),
        currentDir = process.cwd(),
        storage = {
          exists: {}
        };

  async.series(
    [
        testExistence
      , testFlushSystem
      , copy
      , refactor

    ]
    ,
    function(err, results){
      if (err) { abort(err); }
      console.log();
      for (var i = 0; i < results.length; i++) {
        console.log('    ' + results[i].replace(' ', '\t'));
      };
      console.log();
      console.log('    Add the following line to your app.js or main script...');
      console.log();
      console.log('    ->   require(\'./api\')(app);');
      console.log();
    });

    function testExistence(callback){
      async.each(sourceDirs, function(dir, callback){

        var target = path.join(currentDir, dir);
        fs.exists(target, function(exists){
          storage.exists[dir] = exists;
          if (exists && !program.force) {
            callback && callback(new Error(target));
          }
          callback && callback();
        });
      },
      function(err){
        if (err) { callback(err) };
        callback(null, 'existence OK');
      });
    };

    function testFlushSystem(callback){
      if (program.FLUSH) {
        async.each(sourceDirs, function(dir, callback){
          if (storage.exists[dir]) {
            var target = path.join(currentDir, dir);
            wrench.rmdirSyncRecursive(target);
            console.log('     FLUSHED:     ' + target);
          }
        },
        function(err){
          if (err) { callback(err); }
          process.exit(1);
        });
      } else {
        callback && callback(null, 'flush OK');
      }
    };

    function copy(callback){
      async.each(sourceDirs, function(dir, callback){
        var source = path.join(templateDir, dir),
            target = path.join(currentDir, dir);

        wrench.copyDirSyncRecursive(source, target);
        callback && callback();
      },
      function(err){
        if (err) { callback(err); }
        callback(null, 'copy OK');
      });
    };

    function refactor(callback){
      var replacePath = path.join(__dirname, '../node_modules/replace/bin/replace.js'),
          ItemSchemaPath = './data/schemas/item.js',
          ItemModelPath = './data/models/item.js',
          targets = [
                      ItemSchemaPath,
                      ItemModelPath,
                      './api/auth/owner.js'
                    ];

      async.series([
            replaceNames
          , injectBlocks
          , renameFile

        ], function(err, result) { 
          if (err) { abort(err); }
          callback(null, 'refactor OK');
        });

      function replaceNames(callback) {
        async.each(targets, function(dir, callback){
          async.series([
            function(callback){
              var args = ['#{Item}', program.resource.toProperCase(), dir];
              child_process.execFile(replacePath, args, { cwd: currentDir }, function(err, stdout, stderr){
                if (err) { abort(new Error(stderr)); }
                callback && callback();
              });
            },
            function(callback){
              var args = ['#{item}', program.resource.toLowerCase(), dir];
              child_process.execFile(replacePath, args, { cwd: currentDir }, function(err, stdout, stderr){
                if (err) { abort(new Error(stderr)); }
                callback && callback();
              });
            }], function(err, result){
              if (err) { abort(err); }
              callback && callback();
            })
        },
        function(err){
          if (err) { callback(err); }
          callback && callback();
        });
      };
      function renameFile(callback) {
        async.parallel([
            function(callback){
              fs.rename(ItemSchemaPath, ItemSchemaPath.replace('/item', '/' + program.resource.toLowerCase()), function(){
                callback && callback();
              });
            },
            function(callback){
              fs.rename(ItemModelPath, ItemModelPath.replace('/item', '/' + program.resource.toLowerCase()), function(){
                callback && callback();
              });
            }
          ], function(err, results){
          callback && callback();
        });
      };
      function injectBlocks(callback) {
        var targetPath = './data/schemas/item.js';

        var fields = program.args,
            fieldsCode = [''];

        for (var i = 0; i < fields.length; i++) {
          fieldsCode.push('  ' + fields[i]  + ',');
        };

        var args = ['//FIELDS PLACEHOLDER', fieldsCode.join(eol), targetPath];
        child_process.execFile(replacePath, args, { cwd: currentDir }, function(err, stdout, stderr){
          if (err) { abort(new Error(stderr)); }
          callback && callback();
        });
      };
    };

  } else {

    abort('you must provide a resource name');

  }
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */

function abort(str) {
  console.log();
  console.error('    [ABORT:OR-FORCE]    ' + str);
  console.log();
  process.exit(1);
}