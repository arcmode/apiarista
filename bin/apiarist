#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander'),
    async = require('async'),
    wrench = require('wrench'),
    path = require('path'),
    os = require('os'),
    fs = require('fs'),
    child_process = require('child_process');

program
  .version(require('../package').version)
  .option('-r, --resource [ResourceName]', 'generate resource')
  .option('-f, --force', 'force on existing files')
  .option('-X, --FLUSH', 'deletes the api')
  .parse(process.argv);

// end-of-line code

var eol = 'win32' == os.platform() ? '\r\n' : '\n';

// utility to propercase the resource name

String.prototype.toProperCase = function () {
    return this.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
};

if (program.resource) {

  if ('string' === typeof program.resource) {

    var sourceDirs = [
      '/api',
      '/data'
    ];

    var templateDir = path.join(__dirname,
                        '../node_modules/api-template'),
        currentDir = process.cwd(),
        storage = {
          exists: {}
        };

  async.series(
    [
        testExistence
      , testFlushSystem
      , copy
      , refactor

    ]
    ,
    function(err, results){
      if (err) { abort(err); }
      console.log(results);
    });

    function testExistence(callback){
      async.each(sourceDirs, function(dir, callback){

        var target = path.join(currentDir, dir);
        fs.exists(target, function(exists){
          storage.exists[dir] = exists;
          if (exists && !program.force) {
            callback && callback(new Error(target));
          }
          callback && callback();
        });
      },
      function(err){
        if (err) { callback(err) };
        callback(null, 'existence ok');
      });
    };

    function testFlushSystem(callback){
      if (program.FLUSH) {
        async.each(sourceDirs, function(dir, callback){
          if (storage.exists[dir]) {
            var target = path.join(currentDir, dir);
            wrench.rmdirSyncRecursive(target);
            console.log('     FLUSHED:     ' + target);
          }
        },
        function(err){
          if (err) { callback(err); }
          process.exit(1);
        });
      } else {
        callback && callback(null, 'flush ok');
      }
    };

    function copy(callback){
      async.each(sourceDirs, function(dir, callback){
        var source = path.join(templateDir, dir),
            target = path.join(currentDir, dir);

        wrench.copyDirSyncRecursive(source, target);
        callback && callback();
      },
      function(err){
        if (err) { callback(err); }
        callback(null, 'copy ok');
      });
    };

    function refactor(callback){
      var replacePath = path.join(__dirname, '../node_modules/replace/bin/replace.js'),
          ItemSchemaPath = './data/schemas/item.js',
          targets = [
                      ItemSchemaPath,
                      './api/auth/owner.js'
                    ];

      async.series([
            replaceNames
          , renameFile
          , injectBlocks

        ], function(err, result) { 
          if (err) { abort(err); }
          callback(null, 'refactor ok');
        });

      function replaceNames(callback) {
        async.each(targets, function(dir, callback){
          async.series([
            function(callback){
              var args = ['#{Item}', '#{Item}', dir];
              child_process.execFile(replacePath, args, { cwd: currentDir }, function(err, stdout, stderr){
                if (err) { abort(new Error(stderr)); }
                callback && callback();
              });
            },
            function(callback){
              var args = ['#{item}', '#{item}', dir];
              child_process.execFile(replacePath, args, { cwd: currentDir }, function(err, stdout, stderr){
                if (err) { abort(new Error(stderr)); }
                callback && callback();
              });
            }], function(err, result){
              if (err) { abort(err); }
              callback && callback();
            })
        },
        function(err){
          if (err) { callback(err); }
          callback && callback();
        });
      };
      function renameFile(callback) {
        fs.rename(ItemSchemaPath, ItemSchemaPath.replace('#item', '#item'), function(){
          callback && callback();
        });
      };
      function injectBlocks(callback) {
        callback && callback();
      };
    };

  } else {

    abort('you must provide a resource name');

  }
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */

function abort(str) {
  console.error('    [ABORT:OR-FORCE]    ' + str);
  process.exit(1);
}

function appendApiToApp(callback) {

  var requireString = 'require(\'./api\')(app);',
      appCode = [
      ''
    , '/*'
    , ' * Api initialization'
    , ' */'
    , ''
    , requireString
    , ''
  ].join(eol);

  var app = path.join(__dirname, 'app.js');
  fs.exists(app, function(exists){
    if (exists) {
      fs.stat(app, function(err, stats) {
        if (err) { abort(err); }
        fs.open(app, 'a+', 0666, function(err, fd){
          if (err) { abort(err); }
          fs.read(fd, new Buffer(stats.size), 0, stats.size, 0, function(err, bytesRead, buffer) {

            var text = buffer.toString('utf8', 0, bytesRead),
                lines = text.split(eol),
                already = lines.indexOf(requireString) >= 0;

            if (already) {
              console.log('   api already appended to app');
              callback && callback();
            } else {
              fs.write(fd, appCode, null, 'utf8', function(){
                fs.close(fd, function(){
                  console.log('   api just appended to app');
                  callback && calback();
                });
              });
            }

          });
        });
      });
    } else {
      abort('app not found')
    }
  });
};