#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander'),
    async = require('async'),
    wrench = require('wrench'),
    path = require('path'),
    os = require('os'),
    fs = require('fs');

program
  .version(require('../package').version)
  .option('-r, --resource [ResourceName]', 'generate resource')
  .option('-f, --force', 'force on existing files')
  .option('-X, --FLUSH', 'deletes the api')
  .parse(process.argv);

// end-of-line code

var eol = 'win32' == os.platform() ? '\r\n' : '\n';

// utility to propercase the resource name

String.prototype.toProperCase = function () {
    return this.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
};

if (program.resource) {

  if ('string' === typeof program.resource) {

    var sourceDirs = [
      '/api',
      '/data'
    ];

    var templateDir = path.join(__dirname,
                        '../node_modules/api-template'),
        currentDir = process.cwd();

  async.series(
    [
      testExistence
      ,
      testFlushSystem
      ,
      copy
      ,
      refactor

    ]
    ,
    function(err, results){
      if (err) { abort(err); }
      console.log(results);
    });

    function testExistence(callback){
      async.each(sourceDirs, function(dir, callback){

        var target = path.join(currentDir, dir);
        var exists = fs.existsSync(target);

        if (exists && !program.force) {
          callback && callback(new Error(target));
        }
        callback && callback();
      },
      function(err){
        if (err) { callback(err) };
        callback(null, 'existence ok');
      });
    };

    function testFlushSystem(callback){
      if (program.remove) {
        sourceDirs.forEach(function(dir) {
          var target = path.join(currentDir, dir);
          wrench.rmdirSyncRecursive(target);
        });
      }
      callback && callback(null, 'flush ok');
    };

    function copy(callback){
      async.each(sourceDirs, function(dir, callback){
        var source = path.join(templateDir, dir),
            target = path.join(currentDir, dir);

        wrench.copyDirSyncRecursive(source, target);
        callback && callback();
      },
      function(err){
        if (err) { callback(err); }
        callback(null, 'copy ok');
      });
    };

    function refactor(callback){
     callback(null, 'refactor ok');
    };

  } else {

    abort('you must provide a resource name');

  }
}

/**
 * Exit with the given `str`.
 *
 * @param {String} str
 */

function abort(str) {
  console.error('[ABORT:OR-FORCE]    ' + str);
  if (program.forced) {
    console.log('[FORCE:ACTIVATED]    ');
  } else {
    process.exit(1);
  }
}

function appendApiToApp(callback) {

  var requireString = 'require(\'./api\')(app);',
      appCode = [
      ''
    , '/*'
    , ' * Api initialization'
    , ' */'
    , ''
    , requireString
    , ''
  ].join(eol);

  var app = path.join(__dirname, 'app.js');
  fs.exists(app, function(exists){
    if (exists) {
      fs.stat(app, function(err, stats) {
        if (err) { abort(err); }
        fs.open(app, 'a+', 0666, function(err, fd){
          if (err) { abort(err); }
          fs.read(fd, new Buffer(stats.size), 0, stats.size, 0, function(err, bytesRead, buffer) {

            var text = buffer.toString('utf8', 0, bytesRead),
                lines = text.split(eol),
                already = lines.indexOf(requireString) >= 0;

            if (already) {
              console.log('   api already appended to app');
              callback && callback();
            } else {
              fs.write(fd, appCode, null, 'utf8', function(){
                fs.close(fd, function(){
                  console.log('   api just appended to app');
                  callback && calback();
                });
              });
            }

          });
        });
      });
    } else {
      abort('app not found')
    }
  });
};